name: Daily OpenAPI Watch

on:
  schedule:
    - cron: "30 14 * * *"   # 14:30 UTC ≈ 7:30am PT
  workflow_dispatch:

concurrency:
  group: openapi-watcher
  cancel-in-progress: false

jobs:
  watch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write   # for creating Issues

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      # 1) Fetch and update meta/history (writes dated files on change)
      - name: Fetch OpenAPI & update meta/history
        run: node index.mjs

      # 2) Show the last 50 runs in the job summary
      - name: Show last 50 runs in summary
        run: |
          echo "### Last 50 runs" >> $GITHUB_STEP_SUMMARY
          if [ -f logs/runs.log ]; then
            tail -n 50 logs/runs.log >> $GITHUB_STEP_SUMMARY
          else
            echo "_No runs.log yet_" >> $GITHUB_STEP_SUMMARY
          fi

      # 3) Read latest/previous from meta.json
      - name: Read latest/previous from meta
        id: meta
        run: |
          LATEST=$(jq -r '.latestFile' data/meta.json)
          PREV=$(jq -r '.previousFile' data/meta.json)
          echo "From meta -> Latest: $LATEST  Previous: $PREV"
          echo "LATEST=$LATEST" >> $GITHUB_ENV
          echo "PREV=$PREV" >> $GITHUB_ENV

      # 4) Fallback: pick the two most recent **dated spec files** (exclude meta.json)
      - name: Fallback latest/previous from dated files
        if: ${{ env.PREV == '' || env.PREV == 'null' }}
        run: |
          mapfile -t FILES < <(ls -t data/[0-9][0-9][0-9][0-9]-*-*.json 2>/dev/null || true)
          if [ "${#FILES[@]}" -ge 2 ]; then
            LATEST=$(basename "${FILES[0]}")
            PREV=$(basename "${FILES[1]}")
            echo "Fallback -> Latest: $LATEST  Previous: $PREV"
            echo "LATEST=$LATEST" >> $GITHUB_ENV
            echo "PREV=$PREV" >> $GITHUB_ENV
          else
            echo "Not enough dated spec files yet for a diff."
          fi

      # 5) Sanity print the pair
      - name: Print comparison pair
        if: ${{ env.PREV != '' && env.PREV != 'null' }}
        run: |
          echo "Comparing:"
          echo "  base:     data/${{ env.PREV }}"
          echo "  revision: data/${{ env.LATEST }}"
          ls -l "data/${{ env.PREV }}" "data/${{ env.LATEST }}"

      # 6) oasdiff JSON diff (machine-readable)
      - name: oasdiff (JSON)
        if: ${{ env.PREV != '' && env.PREV != 'null' }}
        uses: oasdiff/oasdiff-action/diff@v0.0.21
        with:
          base: data/${{ env.PREV }}
          revision: data/${{ env.LATEST }}
          format: json
          output-to-file: diffs/${{ github.run_id }}.json

      # 7) Ensure a file exists even if the diff is empty (format-only changes)
      - name: Ensure diff artifact exists
        if: ${{ env.PREV != '' && env.PREV != 'null' }}
        run: |
          f="diffs/${{ github.run_id }}.json"
          [ -s "$f" ] || echo '{}' > "$f"

      # 7.5) Detect a real (non-empty) diff
      - name: Is diff non-empty?
        id: diffcheck
        if: ${{ env.PREV != '' && env.PREV != 'null' }}
        run: |
          f="diffs/${{ github.run_id }}.json"
          if jq -e 'length == 0' "$f" >/dev/null 2>&1; then
            echo "nonempty=false" >> $GITHUB_OUTPUT
          else
            echo "nonempty=true" >> $GITHUB_OUTPUT
          fi

      # 7.6) Compute a stable (canonical) hash of the diff content
      - name: Compute diff hash (canonical)
        id: diffhash
        if: steps.diffcheck.outputs.nonempty == 'true'
        run: |
          mkdir -p logs
          f="diffs/${{ github.run_id }}.json"
          # Canonicalize JSON so key ordering doesn't cause false 'new' alerts
          jq -S '.' "$f" > "$f.canon"
          mv "$f.canon" "$f"
          HASH=$(openssl dgst -sha256 "$f" | awk '{print $2}')
          echo "hash=$HASH" >> $GITHUB_OUTPUT
          echo "Current diff hash: $HASH"

      # 7.7) Compare with last notified hash (alert only on new hash)
      - name: Is this a new diff hash?
        id: newhash
        if: steps.diffcheck.outputs.nonempty == 'true'
        run: |
          LAST=""
          [ -f logs/last_diff_hash.txt ] && LAST="$(cat logs/last_diff_hash.txt)"
          echo "Last diff hash: ${LAST:-<none>}"
          if [ "$LAST" != "${{ steps.diffhash.outputs.hash }}" ]; then
            echo "is_new=true" >> $GITHUB_OUTPUT
            echo "${{ steps.diffhash.outputs.hash }}" > logs/last_diff_hash.txt
          else
            echo "is_new=false" >> $GITHUB_OUTPUT
          fi

      # 7.8) Create a GitHub Issue only when diff is non-empty AND hash is new
      - name: Create GitHub issue on new change
        if: steps.diffcheck.outputs.nonempty == 'true' && steps.newhash.outputs.is_new == 'true'
        uses: actions/github-script@v7
        env:
          PREV: ${{ env.PREV }}
          LATEST: ${{ env.LATEST }}
        with:
          script: |
            const fs = require('fs');
            const path = `diffs/${process.env.GITHUB_RUN_ID}.json`;
            const diff = fs.readFileSync(path, 'utf8');
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const title = `OpenAPI change: ${process.env.PREV} → ${process.env.LATEST}`;
            const body = [
              `**Base:** \`data/${process.env.PREV}\``,
              `**Revision:** \`data/${process.env.LATEST}\``,
              `**Run:** ${runUrl}`,
              '',
              '```json',
              diff.length > 60000 ? diff.slice(0, 60000) + '\\n…(truncated)…' : diff,
              '```'
            ].join('\n');

            const label = 'api-change';
            try {
              await github.rest.issues.createLabel({
                owner: context.repo.owner, repo: context.repo.repo, name: label
              });
            } catch (_) { /* already exists */ }

            const created = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: [label]
            });
            core.info(`Created issue #${created.data.number}`);

      # 8) Commit artifacts directly to main (includes logs to keep history, incl. last_diff_hash.txt)
      - name: Commit changes
        run: |
          git config user.name "openapi-bot"
          git config user.email "openapi-bot@example.com"
          git add data diffs logs || true
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: store latest spec + diff + run log [skip ci]"
            git push
          fi
